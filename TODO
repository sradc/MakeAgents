- more examples (with some api call stuff, e.g. to search engines, etc.)
    - tutorials:
        - simple example, just a single function and a prompt
        - sequential pattern, this then this, then this
        - sequential with some loopback
        - wide short pattern (i.e. just one or two layers, but lots available)
        - multi-agent pattern
    - no system prompt example, entirely do through functions,
        (or the system prompt says that),
        then start with an instruction_function(),
        which must be called at the start.
        - could do that as the default :O :D.
            then default to empty messages initially :O,
            leaving the option of passing a system prompt as normal.
    - RAG example, chat
    - SQL example, chat
    - Autonomous example
    - getting name first, then getting phone number (or something)
    - scraping wikipedia/duckduckgo, then doing something else (idk)
    - writing code, and searching stackoverflow if stuck
- gifs for the examples (record in console)
- more unit test coverage
- Also allow action function, for picking actions dynamically.
    - Ok, so idea here is to have 3 options:
        - the simple agent graph, just dict of lists of functions
        - the agent graph with validation, include a pattern with the function
        - get_next_action function <- alternative to agent graph, more powerful, (but can't easily plot :P)
        To implement this, plan is to turn the first 2 options into get_next_action function,
        then call that every time in the loop.
        - Ah crap, also need to handle validation errors, i.e. what to do if pydantic validation fails...
            - i.e. can just retry a few times
            - or can actually take it into account in the graph, and say which actions to take

    based on output of previous output, e.g. to allow actions after validation, etc.
    (maybe rather than conditionals (below))
- conditionals:
    - if get this result, you can then do these
    - otherwise, you can do these...
    (that works for a given input, idk how to make something available for all time if it's "unlocked"...)
    - maybe too much outside logic, maybe the LLM can just handle things?


- tutorial notebook
    - document ways to stop / wait for confirmation before running functions (e.g. when powerful)
- set docs dir in github to `docs`

Low priority:
- ability to check number of tokens with tiktoken
- summariser / reducer (e.g. run before making llm call)
- Check for license in scripts
- Put tutorial notebook/s into jekyll

- [x] doc generation using sphinx
- [x] ability to configure completion, e.g. model etc.
- [x] funcs with no args
- [x] license in scripts
- [x] squash / rebase branch before merging into main, then archive
